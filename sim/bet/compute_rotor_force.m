%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% compute_rotor_force.m
%
% Author: Jo√£o Gaspar
% Last Modified: April 21, 2025
% Version: 1.0
%
% Description:
% This function calculates the total aerodynamic force and torque generated
% by the rotor by integrating the contributions of individual blades over a
% complete revolution (azimuthal positions). It transforms the vehicle and
% wind velocities into each blade's reference frame and sums their effects.
%
% Inputs:
% - SIM: structure containing simulation configuration flags and settings
% - VEHICLE: structure with vehicle state data (position, velocity, orientation)
% - ROTOR: structure with rotor geometry, kinematics, and transformation matrices
% - BLADE: structure with blade-specific aerodynamic and geometric properties
% - ATMOSPHERE: structure containing local atmospheric and wind conditions
%
% Outputs:
% - F_rotor: [3x1] Total aerodynamic force generated by the rotor in the rotor frame
% - T_rotor: [3x1] Total aerodynamic torque generated by the rotor in the rotor frame
% - rotor_distribution_data: object containing detailed per-azimuthal-point force data
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [F_rotor, T_rotor, rotor_distribution_data] = compute_rotor_force(SIM, VEHICLE, ROTOR, BLADE, ATMOSPHERE)

    % Preallocate memory for per-blade forces and torques at each azimuthal point
    F_blade = zeros(3, ROTOR.azimutal_points);
    T_blade = zeros(3, ROTOR.azimutal_points);
    
    F_rotor = zeros(3, 1);
    T_rotor = zeros(3, 1);
    
    blade_distribution_data = [];

    % Compute the rotation matrices from inertial to rotor frame
    ROTOR.R_i_r = rotationMatrix_generator(VEHICLE.orientation(1), VEHICLE.orientation(2), VEHICLE.orientation(3), "deg");
    ROTOR.R_r_i = transpose(ROTOR.R_i_r);

    % Loop over all azimuthal positions
    for k = 1:ROTOR.azimutal_points   
        
        % Rotation matrix from inertial frame to blade frame
        R_i_b = ROTOR.R_i_r * ROTOR.R_r_b(:, :, k);

        % Transform velocities to blade frame
        VEHICLE.velocity_b =  R_i_b * VEHICLE.velocity;
        ATMOSPHERE.wind_velocity_b =  R_i_b * ATMOSPHERE.wind_velocity;
        
        % Compute force and torque for blade k
        [F_blade(:, k), T_blade(:, k), blade_distribution] = compute_blade_force(k, SIM, VEHICLE, ROTOR, BLADE, ATMOSPHERE);

        % Optional debug output
        if SIM.debbug_cmd
            fprintf("\t\t[%.2f] F_b = %.3f %.3f %.3f | T_b =  %.3f %.3f %.3f \n", ROTOR.azimutal_positions(k), F_blade(:, k), T_blade(:, k));
        end

        % Collect azimuthal force/torque data
        blade_distribution_data = [blade_distribution_data blade_distribution];
    end

    % Package azimuthal distribution into output structure
    rotor_distribution_data = RotorAzimutalDistribution(ROTOR.azimutal_positions, blade_distribution_data);

    % Average blade forces/torques over azimuth and multiply by number of blades
    F_rotor = ROTOR.Nb * mean(F_blade, 2);
    T_rotor = ROTOR.Nb * mean(T_blade, 2);
end
